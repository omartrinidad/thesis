% -------------------------------------------------
% Set up a new layer for the debugging marks, and make sure it is on
% top
% this is a good example: https://tex.stackexchange.com/questions/254136/how-do-i-fix-spacing-on-paths-for-a-nested-tikz-flowchart

\pgfdeclarelayer{marx}
\pgfsetlayers{main,marx}
% A macro for marking coordinates (specific to the coordinate naming
% scheme used here). Swap the following 2 definitions to deactivate
% marks.
\providecommand{\cmark}[2][]{%
  \begin{pgfonlayer}{marx}
    \node [nmark] at (c#2#1) {#2};
  \end{pgfonlayer}{marx}
  } 
\providecommand{\cmark}[2][]{\relax} 
% -------------------------------------------------

\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=4mm and 10mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]

{\small\ttfamily\selectfont
% ------------------------------------------------------------------------------ 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=1cm, font={\small}},
  notes/.style={node distance=13cm, align=right},
  diam/.style={base, diamond, aspect=2, text width=5cm},
  diam_small/.style={base, diamond, aspect=2, text width=4cm},
  proc/.style={base, rectangle, text width=7cm},
  proc_small/.style={base, rectangle, text width=8em},
  term/.style={proc, rounded corners, text width=8cm},
  % coord node style is used for placing corners of connecting lines
  coord/.style={coordinate, on chain, on grid, node distance=55mm and 65mm},
  % nmark node style is used for coordinate debugging marks
  nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
  % ----------------------------------------------------------------------------
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw, blue},
  free/.style={->, draw, green},
  cong/.style={->, draw, red},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
% Use join to connect a node to the previous one a

\node [term] (p0) {
    KB $K$, knowledge base;\\
    $minHC$, minimum head coverage;\\
    $maxLen$, size of rules;\\
    $minC$, threshold in the confidence\\
};
\node [proc, join] (q) {
    out = $\langle\rangle$ \\
    q = [$r_1(x, y)$, $r_2(x, y)$,\ldots, $r_m(x,y)$]
};
\node [diam, join] (is_empty) {
    $\lnot q.isEmpty()$
};
\node [proc_small, join] (dequeue) {
    r = q.dequeue()
};
\node [diam_small, font={\small}, join] (accepted_for_output) {
    AcceptedForOutput(r, out, minConf)
};
\node [proc_small, join] (p6) {
    out.add(r)
};
\node [diam_small, join] (check_max_len) {
    len(r) < maxLen
};
\node [proc_small, join] (refinement) {
    R(r) = Refine(r)
};
\node [diam_small, join] (p9) {
    $\lnot$R(r).isEmpty()
};
\node [proc_small, join] (dequeue_refinement) {
    $r_c$ = R(r).dequeue()\\
};
\node [diam_small, join] (check) {
    hc($r_c$) $\leq$ minHC \& $r_c$ $\notin$ q
};
\node [proc_small, join] (p11) {
    q.enqueue($r_c$)
};
\node [proc_small, below of = p11, node distance=2.6cm] (return) {return out};
\node [proc_small, join] (end) {end};

\draw[->] (check.east) -- ++(0.66,0) -- ++(0,-0.05) -- node [near start] {no} ++(0,-3.0) -- ++(-7,0) -- ++(0, 7) -- (p9.north);
\draw[->] (is_empty.east)  -- ++(0,0.0) -- ++(2.35,0) -- node [near start] {no} ++(0,-22.3) -- ++(-4,0) -- (return.north);
\draw[->] (accepted_for_output.east)  -- ++(0,0.0) -- ++(1.35,0) -- node [near start] {no} ++(0,-3.3) -- (check_max_len.north);
\draw[->] (check_max_len.east)  -- ++(0,0.0) -- ++(1.35,0) -- node [near start] {no} ++(0, -12.5) -- ++(-12,0) -- ++(0, 21) -- (is_empty.north);

% notes
\node [notes, right of=q] {q is a queue of rules containing\\all head atoms (size 1)};
\node [notes, right of=is_empty] {Iterate until the queue is empty};
\node [notes, right of=refinement] {The refinement is the expansion of the rule,\\to produce a set of new rules};
\node [notes, right of=dequeue] {Dequeue the rules};
\node [notes, right of=accepted_for_output] {Decide whether to output a rule,\\check for closeness and connectedness,\\among other things, see algorithm 2};
\node [notes, right of=check] {Check if the rules are pruned (by the head coverage) and duplicated};
\node [notes, right of=check_max_len] {Check if the rule exceeds the maximum number of atoms};

% marks
\node[coord, right=of p0] (c0) {}; \cmark{0} 
\node[coord, right=of q] (c1) {}; \cmark{1} 
\node[coord, right=of is_empty] (c2) {}; \cmark{2} 
\node[coord, right=of accepted_for_output] (c3) {}; \cmark{3} 

}
\end{tikzpicture}
